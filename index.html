<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, viewport-fit=cover"
/>
<title>AR Robot Hospital</title>
<style>
  html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
  #ui {
    position: fixed; left: 12px; bottom: 12px; z-index: 10;
    background: rgba(0,0,0,0.55); color: #fff; padding: 10px 12px;
    border-radius: 10px; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    font-size: 14px;
  }
</style>
</head>
<body>
<div id="ui">Move phone to find a surface â†’ Tap to place robot</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128/build/three.module.js';
import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.128/examples/jsm/webxr/ARButton.js';

let scene, camera, renderer;
let reticle;
let hitTestSource = null;
let localRefSpace = null;
let robot = null;
let bedsPlaced = false;

init();
start();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Lighting for AR objects
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1, 2, 1);
  scene.add(dir);

  // Reticle (ring that sits on detected surfaces)
  const ringGeo = new THREE.RingGeometry(0.12, 0.15, 32);
  ringGeo.rotateX(-Math.PI / 2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // AR button (requests 'hit-test' for plane detection)
  document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

  // Session events: set up / clean up hit test source
  renderer.xr.addEventListener('sessionstart', onSessionStart);
  renderer.xr.addEventListener('sessionend', onSessionEnd);

  window.addEventListener('resize', onResize);

  // Tap to place robot
  window.addEventListener('click', placeAtReticle);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

async function onSessionStart() {
  const session = renderer.xr.getSession();

  // viewer space for hit test source
  const viewerSpace = await session.requestReferenceSpace('viewer');
  hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

  // local/world reference space for placing objects
  localRefSpace = renderer.xr.getReferenceSpace();
}

function onSessionEnd() {
  hitTestSource = null;
  localRefSpace = null;
  reticle.visible = false;
}

function start() {
  renderer.setAnimationLoop(render);
}

function render(time, frame) {
  if (frame && hitTestSource && localRefSpace) {
    const hits = frame.getHitTestResults(hitTestSource);
    if (hits.length) {
      const hit = hits[0];
      const pose = hit.getPose(localRefSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else {
      reticle.visible = false;
    }
  }

  renderer.render(scene, camera);
}

// Simple robot made from basic geometry (body + screen + 4 yellow wheels)
function createRobot() {
  const group = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xf8f8f8, roughness: 0.2, metalness: 0.1 });
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.5, 0.25), bodyMat);
  body.position.y = 0.25;
  body.castShadow = body.receiveShadow = false;
  group.add(body);

  const screenMat = new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0x112244, emissiveIntensity: 0.4, metalness: 0.8, roughness: 0.3 });
  const screen = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.14, 0.03), screenMat);
  screen.position.set(0, 0.37, 0.14);
  group.add(screen);

  const wheelMat = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.9, metalness: 0.0 });
  const wheelGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.04, 24);
  const wheelOffsets = [
    [-0.16, 0.08,  0.10],
    [ 0.16, 0.08,  0.10],
    [-0.16, 0.08, -0.10],
    [ 0.16, 0.08, -0.10],
  ];
  wheelOffsets.forEach(([x,y,z]) => {
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI / 2;
    w.position.set(x, y, z);
    group.add(w);
  });

  return group;
}

// Two simple "beds" near the robot (base + mattress)
function createBedAt(x, y, z) {
  const base = new THREE.Mesh(
    new THREE.BoxGeometry(0.9, 0.12, 0.45),
    new THREE.MeshStandardMaterial({ color: 0x999999 })
  );
  base.position.set(x, y + 0.06, z);
  scene.add(base);

  const mattress = new THREE.Mesh(
    new THREE.BoxGeometry(0.9, 0.08, 0.45),
    new THREE.MeshStandardMaterial({ color: 0xffefef })
  );
  mattress.position.set(x, y + 0.16, z);
  scene.add(mattress);
}

function placeAtReticle() {
  if (!reticle.visible) return;

  // Create robot once
  if (!robot) {
    robot = createRobot();
    scene.add(robot);
  }

  // Move robot to the reticle pose
  const m = new THREE.Matrix4().copy(reticle.matrix);
  const pos = new THREE.Vector3().setFromMatrixPosition(m);
  robot.position.copy(pos);

  // Drop two beds nearby (only once)
  if (!bedsPlaced) {
    const y = pos.y; // same floor height
    createBedAt(pos.x + 0.8, y, pos.z - 0.9);
    createBedAt(pos.x - 0.8, y, pos.z - 0.9);
    bedsPlaced = true;
  }
}
</script>
</body>
</html>
